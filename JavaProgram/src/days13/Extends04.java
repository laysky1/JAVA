package days13;

// 일반(상속관계가 없는) 객체의 생성과정
// 1. 멤버변수들을 Heap 메모리에 로딩. 생성
// 2. 생성자 메서드를 호출

// 상속관계가 있는 객체(자식객체)의 생성과정
// 1. 멤버변수들을 Heap 메모리에 로딩. 생성 - 부모/자식 클래스의 모든 멤버변수를 한번에 생성
// 2. 자식 클래스 객체가 생성되는 것이므로 자식 클래스의 생성자가 먼저 호출됩니다.
// 3. 자식 클래스의 생성자의 첫번째 실행코드가 부모클래스의 생성자를 호출합니다.
// 	- 자식 클래스의 생성자 명령중 첫줄이 부모 클래스의 생성자 호출이라는 뜻입니다.
//	- 자식 클래스 생성자 명령 첫줄은 super(); 라는 명령이며, 따로 기술하지 않아도 존재하는 명령입니다.
//	- 디폴트 생성자 처럼 꺼내서 직접 쓰기전까지는 숨어있는 명령이라고 할 수 있습니다.
// 4. 부모클래스 생성자를 모두 실행한 후 자식클래스 생성자의 남은 명령을 실행합니다.
//	- 구조가 이렇게 짜여진 이유를 들자면, 부모클래스의 private 멤버를 자식 클래스의 생성자에서 초기화할 수 없으므로
//	- 부모클래스생성자를 통해 접근하고 초기화하기 위함입니다.

class SuperB{
	private int superNum;
	SuperB(int n){
		superNum=n;
		System.out.println("부모클래스의 생성자 실행");
	}
	//SuperB(){ System.out.println("부모 클래스의 디폴트 생성자 실행");}
	
}
class SubB extends SuperB{
	int subNum;
	// 생성자를 별도로 꺼내서 정의하지 않았다면
	//SubB(){super();}
	//이와 같은 생성자와 명령이 숨어있는 것과 같습니다.
	
	// 생성자를 꺼내서 별도로 정의 한 경우 super() 명령 외에 다른 명령도 쓸 수 있습니다.
	SubB(){
		this(10);
		// 자식 클래스에서 부모클래스 생성자 호출은 super(); 라고 명령하며, 반드시 첫번째 실행코드로 씁니다.
		// super(): 일부러 밖에 꺼내서 쓰지 않아도 이미 자식클래스의 생성자의 첫번째 줄에 존재하는 명령입니다.
		// 다만 super(); 는 부모클래스의 생성자 중 매개변수가 없는 디폴트 생성자를 호출하는 명령이므로,
		// 혹시라도 부모클래스의 생성자가 매개변수있는 생성자로 대체되었다면 이는 에러를 발생합니다.
		
		// 이 에러를 해결할 수 있는 방법(디폴트 클래스에 매개변수를 넣었을때)
		// 1. 부모클래스의 매개변수 형태대로 호출 : super();에 전달인수를 넣어줍니다. super(10);
		// 2. 부모클래스의 생성자를 오버로딩해서 자식클래스 생성자에서 호출하는 형태로 부모클래스 생성자를 추가합니다.
		// 										##super()호출의 두가지 방법핵심##
		//###부모클래스의 생성자형태로 호출하거나, 자식클래스 생성자에서 호출하는 형태로 부모클래스의 생성자가 있거나###
		System.out.println("자식클래스의 생성자 실행");
	}
	
	//매개변수가 있는 생성자로 자식생성자가 오버로딩된 경우...
	SubB(int n){ 
		super(n);
		// 자식클래스의 오버로딩된 생성자의 첫번째 실행 코드는 super(); this(); 가 올수가 있습니다.
		// 한꺼번에 둘다 올 수는 없습니다.
		// 아무것도 쓰지 않으면 super(); 가 호출됩니다.
		// 공교롭게도 부모클래스의 디폴트 생성자가 없다면, 이는 에러입니다.
		// 여기서 선택할 사항은 super(3);을 이용해서 부모클래스의 생성자에 맞게 호출하던가
		// super(3); 형태로 이미 호출하고 있는 형제 생성자를 this();를 이용해서 재호출 하던가.
		System.out.println("자식클래스의 오버로딩된 생성자 실행(this()O)");
	}
	SubB(int subNum, int num){
		super(num); // OR this(num);
		this.subNum = subNum;
		System.out.println("자식클래스의 오버로딩된 생성자 실행(this()X)");
	}
}
// 상속된 자식 클래스의 객체가 만들어질때, 자식 클래스의 생성자가 먼저 호출되고, 
// 자식클래스의 첫번째 명령은 부모클래스의 생성자 호출입니다.
public class Extends04 {

	public static void main(String[] args) {
		SubB b = new SubB();

	}

}

// 1. 자식 클래스 객체 생성(자식 클래스 생성자 호출)
// 2. 자식 클래스 내부에서 부모클래스의 생성자 호출
// 3. 부모클래스 생성자 실행
// * 2번의 부모클래스 호출은 따로 기술하지 않아도 자동으로 자식클래스의 내부 첫번째 명령으로 실행됩니다.
// 4. 자식 클래스의 생성자가 오버로딩 된 경우, 모든 자식 클래스 생성자들은
//	  this() 와 super()명령 중 하나를 선택해야하는데, 둘다 안 쓰면 super();가 자동적용됩니다.
// 5. this() 를 쓰는 경우 호출된 형제 생성자에서 super를 호출해줍니다.










